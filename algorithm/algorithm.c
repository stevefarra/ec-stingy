/*
 * Author: Steve Farra
 *
 * Description: A standalone, real-time version of the cardiac and heart rate monitor
 *              implemented in the Octave script "algorithm.m".
 * 
 *              - Heart rate readings are printed to STDOUT while filtered signals
 *              are written to OUTPUT_FILE and can be displayed by running
 *              "plot_output.m".
 * 
 *              - Comments are used primarily to explain parts of the algorithm
 *              unique to the C version; more details about the program can be
 *              found in the Octave script and in the README.
 *             
 * License: This file is licensed under the MIT license.
 *          See the accompanying LICENSE file for the full text of the license.
 */

/*
 * These are only required for printing to STDOUT and for file I/O; the algorithm
 * itself doesn't require any external libraries.
 */
#include <stdio.h>
#include <string.h>

/*
 * The only new macro is ABS(), which we implement as such to prevent the need
 * for <math.h>.
 */
#define WINDOW(R) (2 * (R) + 1)
#define ABS(x) ((x) < 0 ? -(x) : (x))

/*
 * Modify these filenames as necessary.
 */
#define DATA_FILE   "scope.csv"
#define OUTPUT_FILE "output.csv"

/*
 * The algorithm parameters, which follow similar naming to their Octave
 * counterparts.
 */
#define FS 360
#define N 25
#define S 7
#define L 5
#define M 150
#define BETA 2.5
#define MIN_RR_DIST (0.272 * FS)

/*
 * Signal buffer sizes.
 *
 * - If a filter is succeeded by a moving average filter, then its buffer is
 * one element greater than the successive moving average filter's window
 * size. This is so that the oldest sample (i.e. the sample which just left
 * the window) can be discarded from the current moving average value.
 * 
 * - The high pass buffer is set to store the most recent 2 seconds of ECG
 * data by default, meaning heart rates as low as roughly 30 bpm can be detected.
 * adjust this based on your needs.
 */
#define NOTCHED_SIZE (WINDOW(N) + 1)
#define H_SIZE (FS * 2)
#define T_SIZE (WINDOW(L) + 1)
#define L1_SIZE (WINDOW(M) + 1)

/*
 * Notch filter difference equation parameters generated by pei_tseng_notch()
 * in "algorithm.m".
 * 
 * - B[] contains the feedforward coefficients while A[] contains feedback
 * coefficients.
 * 
 * Note that these values are normalized with a0 = 1, but A[0] is
 * set to 0 to increase code legibility.
 */
static float B[] = {0.9175, -0.9451, 0.9175};
static float A[] = {0, -0.9451, 0.8350};

/**
 * Finds the index of the maximum value in an array within a specified range.
 *
 * @param arr The input array.
 * @param start_idx The starting index of the range.
 * @param end_idx The ending index of the range.
 * @return The index of the maximum value within the specified range.
 */
unsigned short max_index(unsigned short arr[],
                         unsigned short start_idx,
                         unsigned short end_idx) {

    unsigned short max_value = arr[start_idx];
    unsigned short max_index = start_idx;

    for (unsigned short i = start_idx + 1; i <= end_idx; i++) {
        if (arr[i] > max_value) {
            max_value = arr[i];
            max_index = i;
        }
    }

    return max_index;
}

/**
 * Rounds a floating-point value to the nearest integer.
 *
 * @param value The input value.
 * @return The rounded integer value.
 */
int rounded(float value) {
    if (value >= 0) {
        return (int)(value + 0.5f);
    } else {
        return (int)(value - 0.5f);
    }
}

int main() {
    /* Open the input and output files. */
    FILE *input_file = fopen(DATA_FILE, "r");
    FILE *output_file = fopen(OUTPUT_FILE, "w");

    /*
     * Notch filter buffers.
     * The use of indices is forgone for these buffers which are
     * instead zero-initialized to clear out any garbage values
     * that could cause errors.
     */
    unsigned short x[3];
    float y[3];
    memset(x, 0, sizeof(x));
    memset(y, 0, sizeof(y));

    /* R-peak detection signal buffers. */
    unsigned short notched[NOTCHED_SIZE];
    unsigned short h[H_SIZE];
    float t[T_SIZE];
    float l1[L1_SIZE];

    /*
     * Current values of various signals. Those which are associated with
     * moving average filters are used as accumulators and therefore must be
     * zero-initialized.
     */
    unsigned short input;
    float y_val;
    unsigned short notched_val;
    float notched_bar_val = 0;
    short h_hat_val;
    unsigned short h_val;
    float t_val;
    float l1_val = 0;
    float l2_val = 0;
    float th_val;
    float theta;

    /* Designated for-loop index. */
    unsigned short i;

    /*
     * Increases code legibility when an already-incremented index must
     * be used.
     */
    unsigned short j;

    /* Buffer indices. These must be zero-initialized. */
    unsigned short i_notched = 0;
    unsigned short i_h = 0;
    unsigned short i_t = 0;
    unsigned short i_l1 = 0;

    /* Flag indicating whether the current sample is an area of interest (AOI)
     * (i.e. whether we are actively searching for an R-peak). We're interested
     * in the boundary between AOIs and non-AOIs, so we store the previous state as
     * well in order to compute the differential.
     */
    unsigned char prev_aoi;
    unsigned char aoi = 0;
    
    /* Indicates the start of an AOI.*/
    unsigned short i_onset;

    /* Indicates the end of an AOI. */
    unsigned short i_offset;

    /* 
     * Index of candidate R-peak in current AOI. Error correction is performed
     * before this value can be assigned to i_curr_max.
     */
    unsigned short i_cand_max;

    /*
     * Index of most recently found R-peak. Zero-initialized to indicate that
     * no R-peak has been found yet and error correction is therefore not necessary.
     */
    unsigned short i_curr_max = 0;

    /*
     * Index of the previous R-peak. The distance between peaks is used to calculate
     * heart rate.
     */
    unsigned short i_prev_max;

    /* Distance between R-peaks, in samples. */
    float rr;

    /* Heart rate reading, in beats per minute. */
    float bpm;
    
    /*
     * We read samples from an input file and and process it
     * line-by-line to simulate sampling an ADC in real-time. The sample is
     * written to an input variable and processed before the next one is read.
     */
    while (fscanf(input_file, "%i,%*s", &input) != EOF) {

        /* Shift the notch filter buffers to make room for the newest sample. */
        for (i = 0; i < 2; i++) {
            x[i] = x[i + 1];
            y[i] = y[i + 1];
        }
        x[2] = input;

        /* Compute the notch filter difference equation and store it in the buffer. */
        y_val = 0;
        for (i = 0; i < 3; i++) {
            y_val += B[i] * x[2 - i];
            y_val -= A[i] * y[2 - i];
        }
        y[2] = y_val;

        /*
         * The output of the notch filter is cast to an integer type, sacrificing a negligible
         * amount of precision to save some memory. As before, shift the buffer if it's full
         * before storing the value.
         */
        notched_val = (unsigned short) y_val;
        if (i_notched == NOTCHED_SIZE) {
            for (i = 0; i < NOTCHED_SIZE - 1; i++) {
                notched[i] = notched[i + 1];
            }
            i_notched--;
        }
        notched[i_notched++] = notched_val;
        
        /* 
         * The output of the high pass filter is computed incrementally to distribute
         * the computational load across CPU cycles. Each new sample is weighted
         * according to the filter's window size and added to the current value, which acts
         * as an accumulator.
         */
        notched_bar_val += (float) notched_val / WINDOW(N);
        if (i_notched > WINDOW(N)) {
            /* 
             * Once the window size has been reached, we can begin discarding the oldest
             * sample from the accumulator to emulate the sliding motion. This recursive
             * approach similarly reduces the amount of computation performed each sampling period.
             */
            notched_bar_val -= (float) notched[0] / WINDOW(N);

            h_hat_val = notched_val - notched_bar_val;
            h_val = ABS(h_hat_val);

            /* As before, shift the high pass buffer if it's full before storing the value. */
            if (i_h == H_SIZE) {
                for (i = 0; i < H_SIZE - 1; i++) {
                    h[i] = h[i + 1];
                }
                i_h--;

                /* 
                 * Since the R-peak detection uses the output of the high pass filter, the indices
                 * pertaining to it need to be shifted as well.
                 */
                i_onset--;
                i_curr_max--;
                i_prev_max--;
            }
            h[i_h++] = h_val;

            /*
             * The triangle template matching filter requires values spanning WINDOW(S)
             * to be computed. There is little advantage to computing the initial value
             * incrementally like there is with moving average filters, so we wait until
             * enough values are available in memory before activating the filter.
             */
            if (i_h >= WINDOW(S)) {
                j = i_h - 1;
                
                /* Compute the triangle template matching value. */
                t_val = (h[j - S] - h[j - (2 * S)]) * (h[j - S] - h[j]);

                /* Shift the triangle buffer if needed before storing the value. */
                if (i_t == T_SIZE) {
                    for (i = 0; i < T_SIZE - 1; i++) {
                        t[i] = t[i + 1];
                    }
                    i_t--;
                }
                t[i_t++] = t_val;

                /* 
                 * Compute the first low pass filter using the exact same method that was
                 * used for the high pass filter.
                 */
                l1_val += t_val / WINDOW(L);
                if (i_t > WINDOW(L)) {
                    l1_val -= t[0] / WINDOW(L);

                    /* Shift the first low pass buffer if needed before storing the value. */
                    if (i_l1 == L1_SIZE) {
                        for (i = 0; i < L1_SIZE - 1; i++) {
                            l1[i] = l1[i + 1];
                        }
                        i_l1--;
                    }
                    l1[i_l1++] = l1_val;

                    /* 
                     * Compute the second low pass filter using the exact same method that was
                     * used for the other moving average filters. The filter that succeeds this one
                     * is both memoryless and non-casual, so buffering it is unnecessary.
                     */
                    l2_val += l1_val / WINDOW(M);
                    if (i_l1 > WINDOW(M)) {
                        l2_val -= l1[0] / WINDOW(M);
                    }

                    /*
                     * Empirically, the output of the second low pass filter already begins to 
                     * stabilize when only half of the moving window has been computed, so the
                     * threshold value calculation begins past this point.
                     */
                    if (i_l1 > M + 1) {
                        /* The technique of using one-fourth of the statistical mean of
                         * the low-pass filter output as the threshold offset (theta) is not
                         * well-suited to a real-time setting. We use the output of the second low-pass
                         * filter instead, as the window size is large enough to produce a value
                         * that is comparable to the statistical mean.
                         */
                        theta = 0.25 * l2_val;
                        th_val = BETA*l2_val + theta;

                        /*
                         * Check if the current sample is an area of interest.
                         */
                        prev_aoi = aoi;
                        aoi = l1_val >= th_val ? 1 : 0;

                        if (aoi - prev_aoi == 1) {
                            /* Mark the start of an area of interest. */
                            i_onset = i_h;
                        } else if (aoi - prev_aoi == -1) {
                            /* 
                             * Mark the end of an area of interest. The index of the candidate
                             * R-peak corresponds to the maximum value in the high-pass filter output.
                             */
                            i_offset = i_h;
                            i_cand_max = max_index(h, i_onset, i_offset);

                            if (i_curr_max == 0) {
                                /* 
                                 * If no other R-peak has been found so far, the candidate R-peak
                                 * is automatically considered a true R-peak.
                                 */
                                i_curr_max = i_cand_max;
                            } else {
                                /* 
                                 * If an R-peak was previously detected, error correction is performed by
                                 * checking if the candidate R-peak is too close to the most recent R-peak
                                 * to be biologically possible.
                                 */
                                if (i_cand_max - i_curr_max < MIN_RR_DIST) {
                                    /*
                                     * If the peaks are too close together, then keep the R-peak with a
                                     * higher value and discard the other one.
                                     */
                                    if (h[i_cand_max] > h[i_curr_max]) {
                                        i_curr_max = i_cand_max;
                                    } 
                                } else {
                                    /* 
                                     * If no error correction was performed and there have been at least
                                     * two detected R-peaks, the heart rate is calculated and sent to output
                                     * (in this case, STDOUT).
                                     */
                                    i_prev_max = i_curr_max;
                                    i_curr_max = i_cand_max;
                                    rr = i_curr_max - i_prev_max;
                                    bpm = 60.0 * FS / (float) rr;
                                    printf("bpm: %f\n", bpm);
                                }
                            }
                        }           
                    }
                }
            }
        }
        /* 
         * The waveforms are output to a file to for plotting/debugging purposes.
         * Use "plot_output.m" to view these plots.
         */
        fprintf(output_file, "%i,%i,%f,%f,%f,%i\n", h_hat_val, h_val, t_val, l1_val, th_val, aoi);
    }
    /* Close the files. */
    fclose(input_file);
    fclose(output_file);

    return 0;
}